<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0;}
			3DCanvas { width: 100%; height: 100%; position:absolute; top:0px; left:0px; z-index: -1;}

		</style>
	</head>
	<body>


		<script src="js/three.min.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>


		<canvas id="3DCanvas" style="width: 100%; height: 100%; position:absolute; top:0px; left:0px; z-index: -1;"></canvas>

		

		<script>
			var container, stats;

			var camera, scene, renderer, composer;

			var geometry, head, mouth, curve;

			var mouseX = 0, mouseY = 0;

			var followPoint = new THREE.Vector3();

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var scaler = 2.5;

			var circSegs = 32;

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 15000 );
				camera.position.z = 500;

				scene = new THREE.Scene();


				// LIGHTS

				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 1 );
				hemiLight.color.setHSL( 1, 1, 1);
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight );

				// Modelling
				var CustomSinCurve = THREE.Curve.create(
				    function ( scale ) { //custom curve constructor
				        this.scale = (scale === undefined) ? 1 : scale;
				    },
				    
				    function ( t ) { //getPoint: t is between 0-1
				        var tx = t * 3 - 1.5,
				            ty = Math.sin( 2 * Math.PI * t ),
				            tz = 0;
				        
				        return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);
				    }
				);




				// Rendering

				var amount = 1, object, parent = head;

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0Xd7fe6d );
				document.body.appendChild( renderer.domElement );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}


			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove(event) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );


				// Work out and save Follow point 
				var vector = new THREE.Vector3();

				vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				
				vector.unproject( camera );
				
				var dir = vector.sub( camera.position ).normalize();
				
				var distance = - ((camera.position.z / dir.z) + 250);
				
				followPoint = camera.position.clone().add( dir.multiplyScalar( distance ) );

				//console.log(followPoint);

			}

			2
			function animate() {

				scene.remove(curve);
				scene.remove(mouth);

				var mWidth = 50 * scaler;
				var mHeight = 15 * scaler;
				var open = 0 * scaler + (mouseY/20);
				var smile = 2 * scaler + (mouseX/30);

				//Create a closed bent a sine-like wave
				curve = new THREE.ClosedSplineCurve3( [
					new THREE.Vector3( 0, 0 + open, 0 ),
					new THREE.Vector3( mWidth/4, 0  + (open/1.4) + (smile/4), 0 ),	
					new THREE.Vector3( mWidth/2, 0 + smile, 0 ),
					new THREE.Vector3( mWidth/2, mHeight/2 + smile, 0 ),
					new THREE.Vector3( 0, mHeight/2 - (open/2) , 0 ),
					new THREE.Vector3( -mWidth/2, mHeight/2  + smile, 0 ),
					new THREE.Vector3( -mWidth/2, 0  + smile, 0 ),
					new THREE.Vector3( -mWidth/4, 0  + (open/1.4) + (smile/4), 0 )			
				] );

				var l = curve.getPoints();
				

				var mouthGeometry = new THREE.TubeGeometry(
				    curve,  //path
				    150,    //segme2
				    5*scaler,     //radius
				    8,     //radiusSegments
				    true  //closed
				)

				//var mouthMaterial = new THREE.MeshBasicMaterial( { wireframe: true } );
				var mouthMaterial = new THREE.MeshLambertMaterial( { color: 0Xfa76d9, shading: THREE.SmoothShading, overdraw: 1} );


				mouth = new THREE.Mesh( mouthGeometry, mouthMaterial );
				scene.add( mouth );	


				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				//console.log(mouseX);

				var time = Date.now() * 0.001;

				//var rx = Math.sin( mouseX * 4 ) * 0.9;
				//var ry = Math.sin( mouseX * 4 ) * 0;
				//var rz = Math.sin( mouseX * 4 ) * 0;

				var rx = mouseY/ 2000;
				var ry = mouseX/ 2000;
				var rz = mouseX/ 2000;

				//camera.position.x += ( mouseX - camera.position.x ) * .05;
				//camera.position.y += ( - mouseY - camera.position.y ) * .05;

				camera.lookAt( mouth.position );

				renderer.render( scene, camera );

			}

			function resize() { 
			  stage.canvas.width = window.innerWidth;
			  stage.canvas.height = window.innerHeight;     
			}

		</script>

		

	</body>
</html>